{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Raspberry Pi GitOps Stack This document describes my current setup of my Rasperry Pi k8s cluster. Although everything should be reflected in code, usually my brain discards stuff which works ... now. The not-working is a problem for future brain \ud83d\ude04 So the text is mainly meant for me to keep track of how and why I did certain things. If somebody else finds value in it: great! Although the whole thing is a private project for educational purposes, I try to keep it as production ready as possible. Often the biggest learnings stem from corner cases. That means, at least for me, to stay true to the following points: Everything is automated, no manual kubectl commands Clear separation between public and private network Use secure connections All HTTPS connections have correct certificates from LetcEncrypt Disaster recovery is easy to do Critical parts of the system (like control-plane, networking, etc) are setup in HA Vault Secret Injection with CSI One way to use credentials from the vault inside pods is with CSI. Vault post-start command to enable kubernetes auth-method Use Vault with CSI Install CSI Driver CRD with Chart Define a generic SecretProviderClass template as it is needed for each secret (quite a lot of boilerplate) --8<-- \"includes/abbreviations.md\"","title":"Raspberry Pi GitOps Stack"},{"location":"#raspberry-pi-gitops-stack","text":"This document describes my current setup of my Rasperry Pi k8s cluster. Although everything should be reflected in code, usually my brain discards stuff which works ... now. The not-working is a problem for future brain \ud83d\ude04 So the text is mainly meant for me to keep track of how and why I did certain things. If somebody else finds value in it: great! Although the whole thing is a private project for educational purposes, I try to keep it as production ready as possible. Often the biggest learnings stem from corner cases. That means, at least for me, to stay true to the following points: Everything is automated, no manual kubectl commands Clear separation between public and private network Use secure connections All HTTPS connections have correct certificates from LetcEncrypt Disaster recovery is easy to do Critical parts of the system (like control-plane, networking, etc) are setup in HA","title":"Raspberry Pi GitOps Stack"},{"location":"#vault-secret-injection-with-csi","text":"One way to use credentials from the vault inside pods is with CSI. Vault post-start command to enable kubernetes auth-method Use Vault with CSI Install CSI Driver CRD with Chart Define a generic SecretProviderClass template as it is needed for each secret (quite a lot of boilerplate) --8<-- \"includes/abbreviations.md\"","title":"Vault Secret Injection with CSI"}]}