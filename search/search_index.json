{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Raspberry Pi GitOps Stack","text":"<p>This document describes my current setup of my Rasperry Pi k8s cluster. Although everything should be reflected in code, usually my brain discards stuff which works ... now. The not-working is a problem for future brain \ud83d\ude04</p> <p>So the text is mainly meant for me to keep track of how and why I did certain things. If somebody else finds value in it: great!</p> <p>Although the whole thing is a private project for educational purposes, I try to keep it as production ready as possible. Often the biggest learnings stem from corner cases.  That means, at least for me, to stay true to the following points:</p> <ul> <li>Everything is automated, no manual kubectl commands</li> <li>Clear separation between public and private network</li> <li>Use secure connections<ul> <li>All HTTPS connections have correct certificates from LetcEncrypt</li> </ul> </li> <li>Disaster recovery is easy to do</li> <li>Critical parts of the system (like control-plane, networking, etc) are setup in HA</li> </ul>"},{"location":"adguard/","title":"AdGuard","text":""},{"location":"adguard/#setup-adguard-container","title":"Setup AdGuard container","text":"<p>Use the AdGuard container from K8S@Home</p>"},{"location":"adguard/#config-in-opnsense","title":"Config in Opnsense","text":"<p>On my Opnsense firewall I have to configure several things:</p>"},{"location":"argocd/","title":"Argo CD","text":""},{"location":"argocd/#applicationset","title":"ApplicationSet","text":""},{"location":"argocd/#ignore-diffs","title":"Ignore Diffs","text":"diff in applicationset<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\nname: cluster-init\nnamespace: argocd-system\nspec:\ngenerators:\n...\ntemplate:\nspec:\nproject: default\nignoreDifferences:\n- group: \"\"\nkind: ConfigMap\njsonPointers:\n- /data/oidc.config\n- group: \"\"\nkind: Secret\njsonPointers:\n- /data/oidc.authentik.clientSecret\n...\n</code></pre>"},{"location":"argocd/#part-two-oidc-integration","title":"Part Two: OIDC integration","text":"<p>This part should follow after [Vault] and [Authentik] are up and running.</p>"},{"location":"argocd/#oidc-login","title":"OIDC Login","text":"<p>First you have to create a provider and application in authentik to get a client id and secret. Afterwards the oidc credentials can be saved in the Vault and mapped over a <code>SecretProviderClass</code>. (Do not forget to mount the vault volumes for the secret to work [./secrets-csi.md#volumes-in-a-chart])</p> <pre><code>---\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\nname: vault-argocd\nspec:\nprovider: vault\nparameters:\nvaultAddress: \"http://vault.vault:8200\"\nroleName: \"argocd-app\"\nobjects: |\n- objectName: \"oidc-id\"\nsecretPath: \"kv-v2/data/framsburg/argocd/oidc\"\nsecretKey: \"client-id\"\n- objectName: \"oidc-secret\"\nsecretPath: \"kv-v2/data/framsburg/argocd/oidc\"\nsecretKey: \"client-secret\"\nsecretObjects:\n- data:\n- key: oidc.authentik.clientId\nobjectName: oidc-id\n- key: oidc.authentik.clientSecret\nobjectName: oidc-secret\nsecretName: oidc\ntype: Opaque\nlabels:\napp.kubernetes.io/part-of: argocd # (1)!\n</code></pre> <ol> <li>Without this label the secret reference in the argocd ConfigMap will not work and complain about that the secret key can not be found.</li> </ol> <pre><code>argo-cd:\nserver:\n...\nconfig:\nurl: https://argocd.framsburg.ch\noidc.config: | name: Authentik\nissuer: \"https://authentik.framsburg.ch/application/o/argocd/\"\nclientID: \"c579d3195f85aeccaf1ecce35ef5501e023c2a6a\"\nclientSecret: \"$oidc:oidc.authentik.clientSecret\"\nrequestedScopes: [\"openid\", \"profile\", \"email\"]\nlogoutURL: \"https://authentik.framsburg.ch/if/session-end/argocd/\"\nrbacConfig:\npolicy.default: role:readonly\npolicy.csv: |\ng, 'authentik Admins', role:admin\nvolumeMounts:\n- name: 'secrets-store-inline'\nmountPath: '/mnt/secrets-store'\nreadOnly: true\nvolumes:\n- name: secrets-store-inline\ncsi:\ndriver: 'secrets-store.csi.k8s.io'\nreadOnly: true\nvolumeAttributes:\nsecretProviderClass: 'vault-argocd'\n</code></pre>"},{"location":"argocd/#rename-applicationset","title":"Rename Applicationset","text":"<p>Important: Remove Applicationset without cascade delete with the following two options.</p>"},{"location":"argocd/#variant-a-delete-over-cli","title":"Variant A: Delete over CLI","text":"<pre><code>$ kubectl delete ApplicationSet (NAME) --cascade=false\n</code></pre>"},{"location":"argocd/#variant-b-delete-over-gitops","title":"Variant B: Delete over GitOps","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\nname: cluster-apps\nnamespace: argocd-system\nspec:\ngoTemplate: true\nsyncPolicy:\npreserveResourcesOnDeletion: true\n</code></pre> <p>--&gt; Warning should occur of applicationsets are part of two applications (it's actually wrong, but apparently applicationsets are identified only by name)</p> <p>Remove old application set -</p> <p>Go through the following steps</p> <ol> <li>Add app for new applicationset</li> <li>Add preserve resources in old and new applicationset</li> <li>Remove old applicationset</li> <li>Add app to new applicationset one by one</li> </ol>"},{"location":"argocd/#switch-from-applicationset-to-app-of-apps","title":"Switch from Applicationset to App of Apps","text":"<p>To switch from applicationsets to an App of Apps setup we want to delete the superstructure of applicationsets and applications without removing the underlying resources like Pods or VolumeClaims. We do this in multiple steps</p>"},{"location":"argocd/#disable-cascading","title":"Disable cascading","text":"<p>Configure all application sets to preserve their resources. Otherwise the remove of the application set will trigger a deletion cascade to applications and pods, etc.</p> <p>You can do this by defining the following option on the applicationset spec (not the template!!):</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\nname: cluster-apps\nnamespace: argocd-system\nspec:\nsyncPolicy:\npreserveResourcesOnDeletion: true\n</code></pre>"},{"location":"argocd/#remove-applicationset","title":"Remove applicationset","text":"<p>Next step is to delete the applicationset. Make sure to remove them from the initial bootstrap setup otherwise they will be recreated again. This means remove the applicationset from <code>cluster-init/root</code>.</p> <p>After the sync the applicationset should be removed as well as the applications. If this is not the case you can manually remove them with the following command:</p> <pre><code>$ kubectl delete ApplicationSet &lt;NAME&gt; -n argocd-system --cascade=false\n</code></pre>"},{"location":"argocd/#add-new-app-of-apps","title":"Add new app of apps","text":"<p>This can be done anytime even before you start, if your new app of apps does not share the name with an existing application.</p> <p>This is quite straight forward. Add new app of apps to the bootstrap start under <code>apps-root-config/bootstrap/values.yaml</code>.</p>"},{"location":"argocd/#add-app-to-app-of-apps","title":"Add app to app of apps","text":"<p>First make sure the application you want to add is in the right folder. Don't move aka remove it from the old folder as the old application still exists and  would sync your change aka remove the app!</p> <p>Add your app to the new app of apps for example under <code>apps-root-config/applications/cluster-utility-apps.yaml</code></p> <p>This assumes the application name has not changed!. You can now remove the app files from the old folder.</p>"},{"location":"argocd/#github-webhook","title":"GitHub Webhook","text":"<p>This documentation describes how to setup a git webhook which notifies Argo CD on any source changes immedietly. Otherwise Argo CD will pull changes on a three minutes intervall. This follows the Argo CD documentation</p>"},{"location":"argocd/#create-secret-in-vault","title":"Create Secret in Vault","text":"<p>First create an arbitrary secret in the vault for GitHub to use and Argo CD to verify. This is important: As the callback URL must be publicly accessible (because GitHub is public) it opens an attack vector for a DDoS attack. As it not be changed frequently, go for something long ... 50 chars?</p> <p>Add it under <code>framsburg/argocd/github</code> and under key <code>webhook-secret</code>.</p> <p>Create the following external secret which provides this vault secret under the correct secret name. Remeber the k8s secret must be named <code>webhook.github.secret</code></p>"},{"location":"authentik/","title":"Authentik","text":""},{"location":"bare-metal/","title":"Harware Setup of Raspberry PIs","text":"<p>The initial setup is done with Ansible.</p>"},{"location":"bare-metal/#setup-minio-bucket-for-backup","title":"Setup Minio Bucket for Backup","text":"Create minio bucket<pre><code>$ mc mb myminio/k3s\n$ mc mb myminio/k3s/etcd-snapshot\n</code></pre> Create user with policy<pre><code>$ mc admin user add myminio k3s k3sk3sk3s\n\n$ cat &gt; /tmp/etcd-backups-policy.json &lt;&lt;EOF\n{\n  \"Version\": \"2012-10-17\",\n      \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:PutBucketPolicy\",\n        \"s3:GetBucketPolicy\",\n        \"s3:DeleteBucketPolicy\",\n        \"s3:ListAllMyBuckets\",\n        \"s3:ListBucket\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"arn:aws:s3:::k3s\"\n      ],\n      \"Sid\": \"\"\n    },\n    {\n      \"Action\": [\n        \"s3:AbortMultipartUpload\",\n        \"s3:DeleteObject\",\n        \"s3:GetObject\",\n        \"s3:ListMultipartUploadParts\",\n        \"s3:PutObject\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"arn:aws:s3:::k3s/*\"\n      ],\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n$ mc admin policy add myminio etcd-backups-policy /tmp/etcd-backups-policy.json\n\n$ mc admin policy set myminio etcd-backups-policy user=k3s\n</code></pre>"},{"location":"bare-metal/#define-k3s-backup-target","title":"Define K3S backup target","text":"k3s-server.services<pre><code>[Service]\nExecStart={{ k3s_binary_path }}/k3s server \\\n...\n{% if backup_s3_enabled %}\n    --etcd-s3 \\\n    --etcd-snapshot-schedule-cron='{{ backup_schedule_cron }}' \\\n    --etcd-s3-endpoint='{{ backup_s3_endpoint }}' \\\n    --etcd-s3-endpoint-ca='{{ systemd_dir }}/k3s-server.service.crt' \\\n    --etcd-s3-bucket='{{ backup_s3_bucket }}' \\\n    --etcd-s3-folder='{{ backup_s3_folder }}' \\\n    --etcd-s3-access-key='{{ backup_s3_access_key }}' \\\n    --etcd-s3-secret-key='{{ backup_s3_secret_key }}' \\\n{% endif %}\n</code></pre> <p>Define in ansible vault <code>ansible-vault edit group_vars/all.yaml</code> the four coordinates: vault<pre><code>backup_s3_access_key: k3s\nbackup_s3_secret_key: k3sk3sk3s\n</code></pre></p> hosts<pre><code>backup_schedule_cron: '0 */6 * * *'\nbackup_s3_bucket: k3s\nbackup_s3_folder: etcd-snapshot\nbackup_s3_endpoint_ca: |\n-----BEGIN CERTIFICATE-----\nMIIDgTCCAmmgAwIBAgIJAJ85e+K5ngFRMA0GCSqGSIb3DQEBCwUAMGsxCzAJBgNV\n</code></pre>"},{"location":"bare-metal/#optional-rolling-update","title":"(Optional) Rolling Update","text":"<p>The initial ansible script is not very suitable for rolling updates as it assumes it is about to initialize a cluster which requires the order</p> <ol> <li>First master node which initializes (or restores) the etcd state</li> <li>All other master nodes which sync up to the first</li> <li>All worker nodes</li> </ol> <p>That is very efficient for setup and restore but would mean some outages if applied on a live cluster. Therefore we need a playbook which goes through every node sequentially (we have no special requirement on performance) and cares about draining nodes correctly.</p> <p>Ideally we can reuse roles from the cluster setup playbook.</p>"},{"location":"cert-manager/","title":"Cert-Manager","text":""},{"location":"custom-images/","title":"Custom Docker Images","text":"<p>For the task of creating my own images I got inspired by the setup from k8s-at-home and of it's contributers like onedr0p</p>"},{"location":"custom-images/#testing","title":"Testing","text":"<p>Use GOSS.</p> <p>Use <code>dgoss</code> locally which is just a docker wrapper for goss.</p>"},{"location":"custom-images/#references","title":"References","text":""},{"location":"external-secrets/","title":"External Secrets","text":"<p>After some hickups with the vault-secrets-webhook I want to give external secrets a try. With the webhook I had issues with the env variables as not all Helm Charts made it so easy to use like the kube-monitoring-stack: Grafana was using some complicated mapping setup which made it necessary to use Secrets and <code>secret-refs</code>. And thats where my issues started because the vault-secrets-webhook did not reliably replace the placeholders ....</p>"},{"location":"external-secrets/#install-operator","title":"Install Operator","text":"<p>I created a new Helm Chart App for external secrets</p> Chart.yaml<pre><code>apiVersion: v2\nname: external-secrets\nversion: 0.0.0\ndependencies:\n- name: external-secrets\nversion: 0.5.9\nrepository: https://charts.external-secrets.io\n</code></pre> values.yaml<pre><code>external-secrets:\nserviceMonitor:\nenabled: true\n</code></pre> <p>That will create the very basic setup for External Secrets.</p>"},{"location":"external-secrets/#setup-store","title":"Setup Store","text":"<p>The next and most important part is the Secret Store. This is the actual connection to the vault and has the vault coordinates as well as access keys. To make it an easy setup, this is part of the external secrets application.</p> templates/secret-store.yaml<pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ClusterSecretStore\nmetadata:\nname: vault-backend\nspec:\nprovider:\nvault:\nserver: \"http://vault.vault.svc:8200\"\npath: \"kubernetes\"\nversion: \"v2\"\nauth:\n# Authenticate against Vault using a Kubernetes ServiceAccount\n# token stored in a Secret.\n# https://www.vaultproject.io/docs/auth/kubernetes\nkubernetes:\n# Path where the Kubernetes authentication backend is mounted in Vault\nmountPath: \"kubernetes\"\n# A required field containing the Vault Role to assume.\nrole: \"externalSecret\" # (1)\n# Optional service account field containing the name\n# of a kubernetes ServiceAccount\nserviceAccountRef:\nname: \"external-secrets\"\n</code></pre> <ol> <li>This role name has to be created in the Vault or configured for the operator     to create it.</li> </ol>"},{"location":"external-secrets/#usecreate-external-secret","title":"Use/Create external secret","text":"<p>Last step: create a secret over the external secrets operator. Because the store is clusterwide available, the only missing part is the <code>ExternalSecret</code> definition.</p> <p>As an example, the following is the OIDC client id and secret for grafana. I stored all the authentik OIDC clients in the vault. The external secret manifest resides in the templates folder of the monitoring stack.</p> <p>templates/grafana-oidc-secret.yaml<pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: grafana-oidc-secret\nnamespace: monitoring-stack\nspec:\nrefreshInterval: 1m\nsecretStoreRef:\nname: vault-backend # (1)\nkind: ClusterSecretStore\nnamespace: external-secrets\ntarget:\nname: grafana-oidc-secret\ntemplate:\nmetadata:\nlabels:\napp.kubernetes.io/part-of: monitoring-stack\ndata:\n- secretKey: oidc-id\nremoteRef:\nkey: secret/data/framsburg/grafana/oidc # (2)\nproperty: client-id # (3)\n- secretKey: oidc-secret\nremoteRef:\nkey: secret/data/framsburg/grafana/oidc\nproperty: client-secret\n</code></pre> 1.  Name of the configured Secret Store (Make sure the kind is in sync with your     Secret Store) 2.  Path of the secret in Vault. <code>secret</code> is the name of the secret engine,     <code>data</code> is part of the path although not visible in Vault ... some Hashicorp     Vault shenanigan 3.  Key of the secret</p> <p>The generated secret will look like this:</p> <pre><code>\n</code></pre>"},{"location":"external-secrets/#reference","title":"Reference","text":""},{"location":"longhorn/","title":"Longhorn","text":""},{"location":"longhorn/#setup-minio-for-backup","title":"Setup Minio for Backup","text":"<p>Use the minio cli <code>mc</code> which has an alias called <code>myminio</code></p> Create minio bucket<pre><code>$ mc mb myminio/k3sbackups\n$ mc mb myminio/k3sbackups/longhorn\n</code></pre> Create user with policy<pre><code>$ mc admin user add myminio longhorn mypass\n$ cat &gt; /tmp/k3s-backups-policy.json &lt;&lt;EOF\n{\n  \"Version\": \"2012-10-17\",\n      \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:PutBucketPolicy\",\n        \"s3:GetBucketPolicy\",\n        \"s3:DeleteBucketPolicy\",\n        \"s3:ListAllMyBuckets\",\n        \"s3:ListBucket\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"arn:aws:s3:::k3sbackups\"\n      ],\n      \"Sid\": \"\"\n    },\n    {\n      \"Action\": [\n        \"s3:AbortMultipartUpload\",\n        \"s3:DeleteObject\",\n        \"s3:GetObject\",\n        \"s3:ListMultipartUploadParts\",\n        \"s3:PutObject\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": [\n        \"arn:aws:s3:::k3sbackups/*\"\n      ],\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n$ mc admin policy add myminio k3s-backups-policy /tmp/k3s-backups-policy.json\n\n$ mc admin policy set myminio k3s-backups-policy user=longhorn\n</code></pre>"},{"location":"longhorn/#define-backup-target-in-longhorn","title":"Define backup target in longhorn","text":"longhorn values.yaml<pre><code>longhorn:\ndefaultSettings:\nbackupTarget: 's3://k3sbackups@us-east-1/longhorn'\nbackupTargetCredentialSecret: minio-secret\n...\n</code></pre>"},{"location":"metallb/","title":"MetalLB","text":""},{"location":"monitoring/","title":"Monitoring with Prometheus Stack","text":""},{"location":"monitoring/#part-two-oidc-integration","title":"Part Two: OIDC Integration","text":"<p>This part should follow after [Vault] and [Authentik] are up and running.</p>"},{"location":"monitoring/#create-application-in-authentik","title":"Create Application in Authentik","text":"<p>Create a new OIDC provider in authentik with Redirect URIs/Origin pointing to [https://grafana.framsburg.ch]</p> <p>Afterwards create a new application which uses the before created provider. Don't forget to create bindings for uses or groups. You will need the following three informations out of authentik in the next steps.</p> <ul> <li>OpenID Configuration Issuer</li> <li>Client ID</li> <li>Client Secret</li> </ul>"},{"location":"monitoring/#add-secrets-to-vault","title":"Add secrets to vault","text":"<p>To use the vault CLI use the folling command:</p> <pre><code>$ kubectl exec -it vault-0 -n vault -- /bin/sh\n</code></pre> <p>Add the Client ID and the Client Secret as values to the vault:</p> <p>Create the secrets with:</p> <pre><code>$ vault kv put kv-v2/framsburg/grafana/oidc client-id=\"someID\" client-secret=\"someSecret\"\n</code></pre> <p>Create a policy to access the secrets: <pre><code>$ vault policy write grafana-app - &lt;&lt;EOF\npath \"kv-v2/data/framsburg/grafana/*\" {\n  capabilities = [\"read\", \"list\"]\n}\nEOF\n</code></pre></p> <p>Note</p> <p>Please be aware of the added <code>/data/</code>. This is not a typo but something the Vault expects when referencing this secret. It is not displayed in the UI either.</p> <p>And as last step create a role which maps the k8s service account with the policy:</p> <pre><code>$ vault write auth/kubernetes/role/grafana-app \\\nbound_service_account_names=monitoring-stack-grafana \\\nbound_service_account_namespaces=monitoring-stack \\\npolicies=grafana-app \\\nttl=20m\n</code></pre>"},{"location":"monitoring/#secret-class","title":"Secret Class","text":"<p>Create a SecretProviderClass in the templates</p> cluster-critical/monitoring-stack/templates/spc.yaml<pre><code>---\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\nname: vault-grafana\nspec:\nprovider: vault\nparameters:\nvaultAddress: \"http://vault.vault:8200\"\nroleName: \"grafana-app\"\nobjects: |\n- objectName: \"oidc-id\"\nsecretPath: \"kv-v2/data/framsburg/grafana/oidc\"\nsecretKey: \"client-id\"\n- objectName: \"oidc-secret\"\nsecretPath: \"kv-v2/data/framsburg/grafana/oidc\"\nsecretKey: \"client-secret\"\nsecretObjects:\n- data:\n- key: clientId\nobjectName: oidc-id\n- key: clientSecret\nobjectName: oidc-secret\nsecretName: oidc\ntype: Opaque\n</code></pre>"},{"location":"monitoring/#add-volumes-in-a-chart","title":"Add Volumes in a Chart","text":"<p>The Grafana-Chart doesn't allow CSI volumes to be added to the normal volume list. But it has a special value <code>extraSecretMount</code> for those volumes which thankfully even combines the volume and mount entry into one.</p> cluster-critical/monitoring-stack/values.yaml<pre><code>kube-prometheus-stack:\ngrafana:\n...\nextraSecretMounts:\n- name: 'secrets-store-inline'\nmountPath: '/mnt/secrets-store'\nreadOnly: true\ncsi:\ndriver: secrets-store.csi.k8s.io\nreadOnly: true\nvolumeAttributes:\nsecretProviderClass: vault-grafana\n</code></pre>"},{"location":"monitoring/#set-environment-variables-incl-secrets","title":"Set environment variables incl secrets","text":"cluster-critical/monitoring-stack/values.yaml<pre><code>kube-prometheus-stack:\ngrafana:\n...\nenv:\nGF_AUTH_GENERIC_OAUTH_ENABLED: \"true\"\nGF_AUTH_GENERIC_OAUTH_NAME: \"authentik\"\nGF_AUTH_GENERIC_OAUTH_SCOPES: \"openid profile email\"\nGF_AUTH_GENERIC_OAUTH_AUTH_URL: \"https://authentik.framsburg.ch/application/o/authorize/\"\nGF_AUTH_GENERIC_OAUTH_TOKEN_URL: \"https://authentik.framsburg.ch/application/o/token/\"\nGF_AUTH_GENERIC_OAUTH_API_URL: \"https://authentik.framsburg.ch/application/o/userinfo/\"\nGF_AUTH_SIGNOUT_REDIRECT_URL: \"https://authentik.framsburg.ch/application/o/grafana/end-session/\"\n# Optionally enable auto-login (bypasses Grafana login screen)\n# GF_AUTH_OAUTH_AUTO_LOGIN: \"true\"\n# Optionally map user groups to Grafana roles\n# GF_AUTH_GENERIC_OAUTH_ROLE_ATTRIBUTE_PATH: \"contains(groups[*], 'Grafana Admins') &amp;&amp; 'Admin' || contains(groups[*], 'Grafana Editors') &amp;&amp; 'Editor' || 'Viewer'\"\nenvValueFrom:\nGF_AUTH_GENERIC_OAUTH_CLIENT_ID:\nsecretKeyRef:\nname: oidc\nkey: clientId\nGF_AUTH_GENERIC_OAUTH_CLIENT_SECRET:\nsecretKeyRef:\nname: oidc\nkey: clientSecret\n</code></pre>"},{"location":"network/","title":"Network","text":"<p>The Raspberries are in two networks. The internal network and a special DMZ for the external communication of the K8S Cluster. This is not done by actual multiple network interfaces but with vlan.</p> <p>Just by chance my firewall had a free network interface so I chose to actually use a seperate network interface for the DMZ there. I would have used vlan there as well.</p> <p>I could use pure port-forwarding to the MetalLB-IP of the Cluster.</p>"},{"location":"network/#opnsense","title":"Opnsense","text":"<p>On my Opnsense firewall I have to configure several things:</p> <ol> <li>WAN interface to accept inbound web (443) traffic</li> <li>Add NAT port-forward for the MetalLB-IP</li> </ol>"},{"location":"network/#vpn","title":"VPN","text":"<p>The firewall has OpenVPN installed. The users are configured on the firewall and the authentication uses OTPT.</p> <p>The OTP from the Google Authenticator is entered with the password in the following form: <code>&lt;password&gt;&lt;otp&gt;</code>.</p>"},{"location":"plex/","title":"PLEX","text":""},{"location":"plex/#token","title":"Token","text":"<p>Goto www.plex.tv/claim/</p> <p>Set the env variable <code>PLEX_CLAIM</code> to the generated claim token.</p>"},{"location":"plex/#remote-access","title":"Remote Access","text":"<p>Either add an additional entrypoint or use the custom port 443 for the remote port.</p> <p>It is important to adapt the custom hostname to the correct URL including protocol (<code>https://</code>) and Path Prefix like <code>/web</code>.</p>"},{"location":"plex/#readwritemany-for-storage","title":"ReadWriteMany for storage","text":"<p>To upload a lot of files it might be helpful to use <code>ReadWriteMany</code> volumes. This way the can be exposed for upload over samba, nfs or other setups.</p>"},{"location":"plex/#upload","title":"Upload","text":"<pre><code>kubectl cp &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/foo /tmp/bar\n</code></pre>"},{"location":"plex/#change-video-containers-with-ffmpeg","title":"Change video containers with ffmpeg","text":"<pre><code>ffmpeg -i example.mkv -c copy -tag:v hvc1 example.mp4\n</code></pre> <pre><code>for f in *.mkv; do ffmpeg -i \"$f\" -c copy -tag:v hvc1 \"${f%.mkv}.mp4\"; rm \"$f\"; done\n</code></pre>"},{"location":"rails-app/","title":"Rails app on Kubernetes","text":""},{"location":"rails-app/#reference","title":"Reference","text":"<p>some was copied from https://kubernetes-rails.com</p>"},{"location":"secrets-csi/","title":"Secrets with CSI","text":""},{"location":"secrets-csi/#vault-secret-injection-with-csi","title":"Vault Secret Injection with CSI","text":"<p>One way to use credentials from the vault inside pods is with CSI.</p> <ul> <li>Vault post-start command to enable kubernetes auth-method</li> <li>Use Vault with CSI</li> <li>Install CSI Driver CRD with Chart</li> <li>Define a generic SecretProviderClass template as it is needed for each secret (quite a lot of boilerplate)</li> </ul> <p>In case you need the vault command you can easily log into the shell with:</p> <pre><code>$ kubectl exec -it vault-0 -- /bin/sh\n</code></pre> <p>Create the secrets with:</p> <pre><code>$ vault kv put kv-v2/k8s/framsburg/dex client-id=\"someID\" client-secret=\"someSecret\"\n</code></pre> <p>Enable and activate kubernetes auth method <pre><code>$ vault auth enable kubernetes\n$ vault write auth/kubernetes/config \\\nissuer=\"https://kubernetes.default.svc.cluster.local\" \\\ntoken_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\nkubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\\nkubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n</code></pre></p> <p>Create a policy: <pre><code>$ vault policy write dex-app - &lt;&lt;EOF\npolicy dex-app:\npath \"kv-v2/data/k8s/framsburg/dex\" {\n  capabilities = [\"read\"]\n}\nEOF\n</code></pre></p> <p>Write a role to map a service account with a policy</p> <pre><code>$ vault write auth/kubernetes/role/dex-app \\\nbound_service_account_names=dex \\\nbound_service_account_namespaces=dex \\\npolicies=dex-app \\\nttl=20m\nSuccess! Data written to: auth/kubernetes/role/dex-app\n</code></pre>"},{"location":"secrets-csi/#secret-class","title":"Secret Class","text":"<pre><code>---\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\nname: vault-dex\nspec:\nprovider: vault\nparameters:\nvaultAddress: \"http://vault.vault:8200\"\nroleName: \"dex-app\"\nobjects: |\n- objectName: \"oidc-id\"\nsecretPath: \"kv-v2/data/k8s/framsburg/dex\"\nsecretKey: \"client-id\"\n- objectName: \"oidc-secret\"\nsecretPath: \"kv-v2/data/k8s/framsburg/dex\"\nsecretKey: \"client-secret\"\nsecretObjects:\n- data:\n- key: id\nobjectName: oidc-id\n- key: secret\nobjectName: oidc-secret\nsecretName: oidc\ntype: Opaque\n</code></pre>"},{"location":"secrets-csi/#volumes-in-a-chart","title":"Volumes in a Chart","text":"<pre><code>...\nenv:\n- name: GITHUB_CLIENT_ID\nvalueFrom:\nsecretKeyRef:\nname: oidc\nkey: id\n- name: GITHUB_CLIENT_SECRET\nvalueFrom:\nsecretKeyRef:\nname: oidc\nkey: secret\nenvFrom:\n- secretRef:\nname: oidc\n...\nvolumeMounts:\n- name: 'secrets-store-inline'\nmountPath: '/mnt/secrets-store'\nreadOnly: true\nvolumes:\n- name: secrets-store-inline\ncsi:\ndriver: secrets-store.csi.k8s.io\nreadOnly: true\nvolumeAttributes:\nsecretProviderClass: vault-dex\n</code></pre>"},{"location":"traefik/","title":"Traefik","text":"<p>Use two traefik controllers for internal and external network.</p> <p>Issue with only one service <code>api@internal</code> with will mess up the WebUI: The web ui will display for both controllers all services and routes.</p>"},{"location":"uptime-kuma/","title":"Uptime Kuma","text":""},{"location":"vault/","title":"Hashicorp Vault","text":"<p>For operating the Vault inside K8S it is a good idea to use the Banzaicloud Vault-Operator. It automates some the integration and HA tasks.</p>"},{"location":"vault/#install-the-operator","title":"Install the operator","text":"<p>Define a new Chart with a dependencies to the Vault-Operator Chart in the app of apps for the vault-operator with the following values:</p> <pre><code>vault-operator:\ncrdAnnotations:\n\"helm.sh/hook\": crd-install\n</code></pre>"},{"location":"vault/#install-vault","title":"Install Vault","text":"<p>Define a new empty Chart with the following templates inside:</p> <p>```yaml:rbac.yaml kind: ServiceAccount apiVersion: v1 metadata:   name: vault</p> <p>kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: vault rules:   - apiGroups: [\"\"]     resources: [\"secrets\"]     verbs: [\"*\"]   - apiGroups: [\"\"]     resources: [\"pods\"]     verbs: [\"get\", \"update\", \"patch\"]</p> <p>kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: vault roleRef:   kind: Role   name: vault   apiGroup: rbac.authorization.k8s.io subjects:   - kind: ServiceAccount     name: vault</p>"},{"location":"vault/#this-binding-allows-the-deployed-vault-instance-to-authenticate-clients","title":"This binding allows the deployed Vault instance to authenticate clients","text":""},{"location":"vault/#through-kubernetes-serviceaccounts-if-configured-so","title":"through Kubernetes ServiceAccounts (if configured so).","text":"<p>apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata:   name: vault-auth-delegator roleRef:   apiGroup: rbac.authorization.k8s.io   kind: ClusterRole   name: system:auth-delegator subjects:   - kind: ServiceAccount     name: vault     namespace: default <pre><code>## Use secrets\n\nYou always have to map the secrets in different ways. You can find a detailed\ndescription on [banzais website](https://banzaicloud.com/docs/bank-vaults/mutating-webhook/)\n\n### As envrionment variable\n\nPod should have the following annotations:\n\n```yaml\nannotations:\n  vault.security.banzaicloud.io/vault-addr: \"http://vault.vault.svc:8200\"\n  vault.security.banzaicloud.io/vault-path: \"kubernetes\"\n  vault.security.banzaicloud.io/vault-role: \"test\"\n  vault.security.banzaicloud.io/vault-skip-verify: \"true\"\n</code></pre></p> <p>You should adapt the role to the corresponding role you want to use. You can then use secrets in environment variables like this:</p> <pre><code>env:\n- name: GITHUB_CLIENT_ID\nvalue: vault:secret/data/framsburg/test#github_token\n</code></pre>"},{"location":"vault/#as-secret","title":"As secret","text":"<p>The approach with secrets looks quite similar. The main difference is, that you have to provide the path to the secret base64 encoded.</p> <pre><code>$ echo -n vault:secret/data/framsburg/test#github_token | base64\ndmF1bHQ6c2VjcmV0L2RhdGEvZnJhbXNidXJnL3Rlc3QjZ2l0aHViX3Rva2Vu\n</code></pre> <p>Then prepare the secret accodringly:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: some-secret\ndata:\nGITHUB_CLIENT_ID: dmF1bHQ6c2VjcmV0L2RhdGEvZnJhbXNidXJnL3Rlc3QjZ2l0aHViX3Rva2Vu\ntype: Opaque\n</code></pre>"},{"location":"vault/#inline","title":"Inline","text":"<p>Instead of environment variables or secrets you can use the vault key reference anywhere in resources and the webhook will replace it with the secret.</p>"}]}